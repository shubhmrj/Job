import os
from pathlib import Path
from typing import List

try:
    import openai  # Optional – only used if OPENAI_API_KEY exists
except ImportError:
    openai = None

try:
    from docx import Document
except ImportError:
    Document = None

import matplotlib.pyplot as plt
import matplotlib.patches as patches

OUTPUT_DOC = Path(__file__).parent / "new_questions.docx"
IMAGE_PATH = Path(__file__).parent / "images"
IMAGE_PATH.mkdir(exist_ok=True)


def create_image_question2(filepath: Path, radius: float = 1.5):
    """Create a simple top-view image of 8 tightly packed spheres (2 × 4 layout).

    The image is purely illustrative and not drawn to scale, but shows the packing
    arrangement. It will be embedded (or linked) in the Word doc that is generated.
    """
    d = 2 * radius
    fig, ax = plt.subplots(figsize=(4, 2))
    # Draw 2 rows × 4 columns of circles
    for row in range(2):
        for col in range(4):
            circle = patches.Circle((col * d + radius, row * d + radius), radius, edgecolor='black', facecolor='lightblue')
            ax.add_patch(circle)
    ax.set_aspect('equal')
    ax.set_xlim(0, 4 * d)
    ax.set_ylim(0, 2 * d)
    ax.axis('off')
    fig.savefig(filepath, bbox_inches='tight', dpi=150)
    plt.close(fig)


def build_question_blocks() -> List[str]:
    """Return the two question blocks in the specified output format."""
    q1 = """@title Sandwich Combinations Assessment
@description Counting possible sandwich combinations given bread and filling choices.
@question A cafeteria offers 3 varieties of bread (white, wheat, rye) and 4 types of fillings (turkey, ham, cheese, tuna). Assuming a sandwich consists of exactly 1 bread and 1 filling, how many distinct sandwiches can be made?
@instruction Choose the correct answer.
@difficulty easy
@Order 1
@option Seven
@option Nine
@@option Twelve
@option Fifteen
@option Eighteen
@explanation The sandwich choice can be modelled using the Fundamental Principle of Counting. There are 3 choices for bread and 4 for filling, so total combinations = $3\times4=12$.
@subject Quantitative Math
@unit Data Analysis & Probability
@topic Counting & Arrangement Problems
@plusmarks 1"""

    # Question 2 – note the image placeholder; actual file generated by this script
    q2_image = IMAGE_PATH / "question2_top_view.png"
    create_image_question2(q2_image)

    q2 = f"""@title Sphere Package Dimensions
@description Determining the dimensions of a rectangular package containing tightly packed spheres.
@question The top view of a rectangular package containing 8 tightly packed identical balls is shown below. Each ball has a radius of $1.5\,\text{{cm}}$. Which of the following are closest to the dimensions, in centimetres, of the rectangular package?\n![Top view of 8 tightly packed balls arranged in 2 rows of 4]({q2_image.name})
@instruction Select the option that best approximates the package dimensions (height × width × length).
@difficulty moderate
@Order 2
@option $3 \times 6 \times 9$
@option $4.5 \times 6 \times 12$
@@option $3 \times 6 \times 12$
@option $6 \times 9 \times 12$
@option $6 \times 12 \times 15$
@explanation Each ball has diameter $2r=3\,\text{{cm}}$. In a $2\times4$ arrangement, length = $4\times3=12$, width = $2\times3=6$, and height (single layer) = $3$. Thus the closest dimensions are $3\,\text{{cm}} \times 6\,\text{{cm}} \times 12\,\text{{cm}}$.
@subject Quantitative Math
@unit Geometry and Measurement
@topic Area & Volume
@plusmarks 1"""

    return [q1, q2]


def save_to_docx(blocks: List[str]):
    if Document is None:
        print("python-docx is not installed; skipping .docx creation. Install python-docx to enable.")
        return
    doc = Document()
    doc.add_heading('Generated Assessment Questions', level=1)
    for block in blocks:
        for line in block.split('\n'):
            doc.add_paragraph(line)
        doc.add_paragraph('')
    doc.save(OUTPUT_DOC)
    print(f"Saved Word document to: {OUTPUT_DOC}")


def main():
    blocks = build_question_blocks()
    # Print blocks to stdout for immediate viewing
    print("\n\n".join(blocks))
    save_to_docx(blocks)


if __name__ == "__main__":
    main()
